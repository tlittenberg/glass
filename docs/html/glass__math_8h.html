<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLASS: utils/src/glass_math.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="GLASS.png"/></td>
  <td id="projectalign">
   <div id="projectname">GLASS
   </div>
   <div id="projectbrief">Global LISA Analysis Software Suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('glass__math_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">glass_math.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Common math functions used throughout GLASS library.  
<a href="#details">More...</a></p>

<p><a href="glass__math_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCubicSpline.html">CubicSpline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af50bbbd6e446a6774673d52c9eefc233" id="r_af50bbbd6e446a6774673d52c9eefc233"><td class="memItemLeft" align="right" valign="top"><a id="af50bbbd6e446a6774673d52c9eefc233" name="af50bbbd6e446a6774673d52c9eefc233"></a>
struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_cubic_spline</b> (int N)</td></tr>
<tr class="separator:af50bbbd6e446a6774673d52c9eefc233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389ec1a6ef90acd3f0b24d69a6c26a85" id="r_a389ec1a6ef90acd3f0b24d69a6c26a85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a389ec1a6ef90acd3f0b24d69a6c26a85">initialize_cubic_spline</a> (struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *spline, double *x, double *y)</td></tr>
<tr class="memdesc:a389ec1a6ef90acd3f0b24d69a6c26a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes cubic spline coefficients for input data {x,y}.  <br /></td></tr>
<tr class="separator:a389ec1a6ef90acd3f0b24d69a6c26a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2937343ad2760e23ab37de5ec99ae68" id="r_ac2937343ad2760e23ab37de5ec99ae68"><td class="memItemLeft" align="right" valign="top"><a id="ac2937343ad2760e23ab37de5ec99ae68" name="ac2937343ad2760e23ab37de5ec99ae68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_cubic_spline</b> (struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *spline)</td></tr>
<tr class="separator:ac2937343ad2760e23ab37de5ec99ae68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6610ef8e1a58a6de67fb414c49e38" id="r_a4bd6610ef8e1a58a6de67fb414c49e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd6610ef8e1a58a6de67fb414c49e38">spline_coefficients</a> (struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *spline)</td></tr>
<tr class="memdesc:a4bd6610ef8e1a58a6de67fb414c49e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">GLASS implementation of solving for cubic spline interpolation coefficients.  <br /></td></tr>
<tr class="separator:a4bd6610ef8e1a58a6de67fb414c49e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb2d6e5f88d4eaa515af8fbc9228ba9" id="r_a4bb2d6e5f88d4eaa515af8fbc9228ba9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bb2d6e5f88d4eaa515af8fbc9228ba9">spline_interpolation</a> (struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *spline, double x)</td></tr>
<tr class="memdesc:a4bb2d6e5f88d4eaa515af8fbc9228ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">GLASS implementation of cubic spline interpolation.  <br /></td></tr>
<tr class="separator:a4bb2d6e5f88d4eaa515af8fbc9228ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0991e1b8cd35fb89493af66a6bd6d6" id="r_a3c0991e1b8cd35fb89493af66a6bd6d6"><td class="memItemLeft" align="right" valign="top"><a id="a3c0991e1b8cd35fb89493af66a6bd6d6" name="a3c0991e1b8cd35fb89493af66a6bd6d6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>spline_interpolation_deriv</b> (struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *spline, double x)</td></tr>
<tr class="separator:a3c0991e1b8cd35fb89493af66a6bd6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8270e41814a7c86a685a33afe44a19ab" id="r_a8270e41814a7c86a685a33afe44a19ab"><td class="memItemLeft" align="right" valign="top"><a id="a8270e41814a7c86a685a33afe44a19ab" name="a8270e41814a7c86a685a33afe44a19ab"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>spline_interpolation_deriv2</b> (struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *spline, double x)</td></tr>
<tr class="separator:a8270e41814a7c86a685a33afe44a19ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa832de50c97ec75e53423259310ab758" id="r_aa832de50c97ec75e53423259310ab758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa832de50c97ec75e53423259310ab758">invert_noise_covariance_matrix</a> (struct <a class="el" href="structNoise.html">Noise</a> *noise)</td></tr>
<tr class="memdesc:aa832de50c97ec75e53423259310ab758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytic in-place inversion of noise covariance matrix.  <br /></td></tr>
<tr class="separator:aa832de50c97ec75e53423259310ab758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44d01bd4c020c57a52e5e31f0d303bb" id="r_af44d01bd4c020c57a52e5e31f0d303bb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af44d01bd4c020c57a52e5e31f0d303bb">chirpmass</a> (double m1, double m2)</td></tr>
<tr class="memdesc:af44d01bd4c020c57a52e5e31f0d303bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute chirp mass from component masses.  <br /></td></tr>
<tr class="separator:af44d01bd4c020c57a52e5e31f0d303bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22b5cf047831bcb6050b4278ef575d" id="r_a3a22b5cf047831bcb6050b4278ef575d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a22b5cf047831bcb6050b4278ef575d">symmetric_mass_ratio</a> (double Mchirp, double Mtotal)</td></tr>
<tr class="memdesc:a3a22b5cf047831bcb6050b4278ef575d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute symmetric mass ratio of binary.  <br /></td></tr>
<tr class="separator:a3a22b5cf047831bcb6050b4278ef575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec422a6a8b4a3eb5f4e1c5c38d7036e" id="r_a5ec422a6a8b4a3eb5f4e1c5c38d7036e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec422a6a8b4a3eb5f4e1c5c38d7036e">component_masses</a> (double Mchirp, double Mtotal, double *m1, double *m2)</td></tr>
<tr class="memdesc:a5ec422a6a8b4a3eb5f4e1c5c38d7036e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute component masses of binary.  <br /></td></tr>
<tr class="separator:a5ec422a6a8b4a3eb5f4e1c5c38d7036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bc87538a6fac156140a346db7c9d48" id="r_a09bc87538a6fac156140a346db7c9d48"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09bc87538a6fac156140a346db7c9d48">amplitude</a> (double Mc, double f0, double D)</td></tr>
<tr class="memdesc:a09bc87538a6fac156140a346db7c9d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute GW amplitude from intrinsic parameters.  <br /></td></tr>
<tr class="separator:a09bc87538a6fac156140a346db7c9d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923c5b7dac33e19c6deca03e9c67e7af" id="r_a923c5b7dac33e19c6deca03e9c67e7af"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a923c5b7dac33e19c6deca03e9c67e7af">post_newtonian_time</a> (double Mchirp, double Mtotal, double tc, double f)</td></tr>
<tr class="memdesc:a923c5b7dac33e19c6deca03e9c67e7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low PN approximation of current time given the frequency.  <br /></td></tr>
<tr class="separator:a923c5b7dac33e19c6deca03e9c67e7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49367382c598af842abd855c380a2259" id="r_a49367382c598af842abd855c380a2259"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49367382c598af842abd855c380a2259">post_newtonian_frequency</a> (double Mchirp, double tc, double t)</td></tr>
<tr class="memdesc:a49367382c598af842abd855c380a2259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low PN approximation of gravitational wave frequency given time until coalesence.  <br /></td></tr>
<tr class="separator:a49367382c598af842abd855c380a2259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda7243d9d6427acdcf175555f631f6" id="r_a6bda7243d9d6427acdcf175555f631f6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bda7243d9d6427acdcf175555f631f6">ipow</a> (double x, int n)</td></tr>
<tr class="memdesc:a6bda7243d9d6427acdcf175555f631f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute integer powers of x by brute force multiplication.  <br /></td></tr>
<tr class="separator:a6bda7243d9d6427acdcf175555f631f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e50226df581da9b3949b2e81e24c4" id="r_a0a4e50226df581da9b3949b2e81e24c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a4e50226df581da9b3949b2e81e24c4">tukey</a> (double *data, double alpha, int N)</td></tr>
<tr class="memdesc:a0a4e50226df581da9b3949b2e81e24c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tukey window time series data.  <br /></td></tr>
<tr class="separator:a0a4e50226df581da9b3949b2e81e24c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af553670dfd20fb14acb04118e58d0497" id="r_af553670dfd20fb14acb04118e58d0497"><td class="memItemLeft" align="right" valign="top"><a id="af553670dfd20fb14acb04118e58d0497" name="af553670dfd20fb14acb04118e58d0497"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>tukey_scale</b> (double alpha, int N)</td></tr>
<tr class="separator:af553670dfd20fb14acb04118e58d0497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2121b53962cd06c45427ff4dce42f70c" id="r_a2121b53962cd06c45427ff4dce42f70c"><td class="memItemLeft" align="right" valign="top"><a id="a2121b53962cd06c45427ff4dce42f70c" name="a2121b53962cd06c45427ff4dce42f70c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>detrend</b> (double *data, int N, int Navg)</td></tr>
<tr class="separator:a2121b53962cd06c45427ff4dce42f70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7284c2ae59147817959d833bdd8df76c" id="r_a7284c2ae59147817959d833bdd8df76c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7284c2ae59147817959d833bdd8df76c">unpack_fft_output</a> (double *x, double *x_packed, int N)</td></tr>
<tr class="memdesc:a7284c2ae59147817959d833bdd8df76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearrange output ofRFT.  <br /></td></tr>
<tr class="separator:a7284c2ae59147817959d833bdd8df76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8a994980adb0c0bc32ec26d52653b0" id="r_abf8a994980adb0c0bc32ec26d52653b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf8a994980adb0c0bc32ec26d52653b0">glass_forward_complex_fft</a> (double *data, int N)</td></tr>
<tr class="memdesc:abf8a994980adb0c0bc32ec26d52653b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrappers to FFT functions.  <br /></td></tr>
<tr class="separator:abf8a994980adb0c0bc32ec26d52653b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac418bab102f236ae2b006c24a13cb220" id="r_ac418bab102f236ae2b006c24a13cb220"><td class="memItemLeft" align="right" valign="top"><a id="ac418bab102f236ae2b006c24a13cb220" name="ac418bab102f236ae2b006c24a13cb220"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>glass_inverse_complex_fft</b> (double *data, int N)</td></tr>
<tr class="separator:ac418bab102f236ae2b006c24a13cb220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525d77dd4300ac09ae8712534b7d4bf9" id="r_a525d77dd4300ac09ae8712534b7d4bf9"><td class="memItemLeft" align="right" valign="top"><a id="a525d77dd4300ac09ae8712534b7d4bf9" name="a525d77dd4300ac09ae8712534b7d4bf9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>glass_forward_real_fft</b> (double *data, int N)</td></tr>
<tr class="separator:a525d77dd4300ac09ae8712534b7d4bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014d13ca76ef4d52611b696e2c78d39" id="r_a9014d13ca76ef4d52611b696e2c78d39"><td class="memItemLeft" align="right" valign="top"><a id="a9014d13ca76ef4d52611b696e2c78d39" name="a9014d13ca76ef4d52611b696e2c78d39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>glass_inverse_real_fft</b> (double *data, int N)</td></tr>
<tr class="separator:a9014d13ca76ef4d52611b696e2c78d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b3858ec1f4cad3447ac81c71bd56fa" id="r_a04b3858ec1f4cad3447ac81c71bd56fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b3858ec1f4cad3447ac81c71bd56fa">power_spectrum</a> (double *data, int n)</td></tr>
<tr class="memdesc:a04b3858ec1f4cad3447ac81c71bd56fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute power of complex amplitude in single element of data.  <br /></td></tr>
<tr class="separator:a04b3858ec1f4cad3447ac81c71bd56fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd4cf43262bfd30a5d6707c6c078d5f" id="r_a3bd4cf43262bfd30a5d6707c6c078d5f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bd4cf43262bfd30a5d6707c6c078d5f">fourier_nwip</a> (double *a, double *b, double *invC, int N)</td></tr>
<tr class="memdesc:a3bd4cf43262bfd30a5d6707c6c078d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourier-domain noise weighted inner product.  <br /></td></tr>
<tr class="separator:a3bd4cf43262bfd30a5d6707c6c078d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3648f6df79e0a3e15def174fe7ccfcf0" id="r_a3648f6df79e0a3e15def174fe7ccfcf0"><td class="memItemLeft" align="right" valign="top"><a id="a3648f6df79e0a3e15def174fe7ccfcf0" name="a3648f6df79e0a3e15def174fe7ccfcf0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>wavelet_nwip</b> (double *a, double *b, double *invC, int *list, int N)</td></tr>
<tr class="separator:a3648f6df79e0a3e15def174fe7ccfcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a868b858e559d8a660ef849bdce1cb" id="r_ab4a868b858e559d8a660ef849bdce1cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a868b858e559d8a660ef849bdce1cb">binary_search</a> (double *array, int nmin, int nmax, double x)</td></tr>
<tr class="memdesc:ab4a868b858e559d8a660ef849bdce1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our implementation of the recursive binary search algorithm.  <br /></td></tr>
<tr class="separator:ab4a868b858e559d8a660ef849bdce1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd7b3dc905454c44965aac3d9a71afb" id="r_a3fd7b3dc905454c44965aac3d9a71afb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd7b3dc905454c44965aac3d9a71afb">matrix_eigenstuff</a> (double **matrix, double **evectors, double *evalues, int N)</td></tr>
<tr class="memdesc:a3fd7b3dc905454c44965aac3d9a71afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvectors and eigenvalues of matrix.  <br /></td></tr>
<tr class="separator:a3fd7b3dc905454c44965aac3d9a71afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1081e9f1e9ee4e1eb158abe18efc4656" id="r_a1081e9f1e9ee4e1eb158abe18efc4656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1081e9f1e9ee4e1eb158abe18efc4656">invert_matrix</a> (double **matrix, int N)</td></tr>
<tr class="memdesc:a1081e9f1e9ee4e1eb158abe18efc4656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inversion with replacement.  <br /></td></tr>
<tr class="separator:a1081e9f1e9ee4e1eb158abe18efc4656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6968b1b7d05ba7e20fc3e548a2b88de" id="r_ae6968b1b7d05ba7e20fc3e548a2b88de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6968b1b7d05ba7e20fc3e548a2b88de">decompose_matrix</a> (double **matrix, double **inverse, double **L, double *det, int N)</td></tr>
<tr class="memdesc:ae6968b1b7d05ba7e20fc3e548a2b88de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix inversion preserving original and returning L and det.  <br /></td></tr>
<tr class="separator:ae6968b1b7d05ba7e20fc3e548a2b88de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc14e2c155fe0111000033f22a7a3c3b" id="r_acc14e2c155fe0111000033f22a7a3c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc14e2c155fe0111000033f22a7a3c3b">matrix_multiply</a> (double **A, double **B, double **AB, int N)</td></tr>
<tr class="memdesc:acc14e2c155fe0111000033f22a7a3c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication.  <br /></td></tr>
<tr class="separator:acc14e2c155fe0111000033f22a7a3c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431c31bce9711b866999db85774919a" id="r_a2431c31bce9711b866999db85774919a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2431c31bce9711b866999db85774919a">cholesky_decomp</a> (double **A, double **L, int N)</td></tr>
<tr class="memdesc:a2431c31bce9711b866999db85774919a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK Cholesky decomposition routine.  <br /></td></tr>
<tr class="separator:a2431c31bce9711b866999db85774919a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6346e26742eefbbdbfb6b4980b88bd" id="r_a1e6346e26742eefbbdbfb6b4980b88bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e6346e26742eefbbdbfb6b4980b88bd">CubicSplineGLASS</a> (int N, double *x, double *y, int Nint, double *xint, double *yint)</td></tr>
<tr class="memdesc:a1e6346e26742eefbbdbfb6b4980b88bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to <code>GLASS</code> cubic spline interpolation routines.  <br /></td></tr>
<tr class="separator:a1e6346e26742eefbbdbfb6b4980b88bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f2679b2ccec317305f387e938aad16" id="r_aa1f2679b2ccec317305f387e938aad16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1f2679b2ccec317305f387e938aad16">dbscan</a> (double *X, double eps, int min, int C[], int *K, int size)</td></tr>
<tr class="memdesc:aa1f2679b2ccec317305f387e938aad16"><td class="mdescLeft">&#160;</td><td class="mdescRight">GLASS implementation of DBSCAN clustering algorithm.  <br /></td></tr>
<tr class="separator:aa1f2679b2ccec317305f387e938aad16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee759a4b7db7f81a483120aa4493240a" id="r_aee759a4b7db7f81a483120aa4493240a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee759a4b7db7f81a483120aa4493240a">unwrap_phase</a> (int N, double *phase)</td></tr>
<tr class="memdesc:aee759a4b7db7f81a483120aa4493240a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform periodic to linear phase.  <br /></td></tr>
<tr class="separator:aee759a4b7db7f81a483120aa4493240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35c7142c65fb22577688f6e968b2e9b" id="r_ab35c7142c65fb22577688f6e968b2e9b"><td class="memItemLeft" align="right" valign="top"><a id="ab35c7142c65fb22577688f6e968b2e9b" name="ab35c7142c65fb22577688f6e968b2e9b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>simpson_integration_3</b> (double f0, double f1, double f2, double h)</td></tr>
<tr class="separator:ab35c7142c65fb22577688f6e968b2e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf047b1892dab605ac3d79ed7f4c2c3e" id="r_acf047b1892dab605ac3d79ed7f4c2c3e"><td class="memItemLeft" align="right" valign="top"><a id="acf047b1892dab605ac3d79ed7f4c2c3e" name="acf047b1892dab605ac3d79ed7f4c2c3e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>simpson_integration_5</b> (double f0, double f1, double f2, double f3, double f4, double h)</td></tr>
<tr class="separator:acf047b1892dab605ac3d79ed7f4c2c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7e5ac801b5b5197f707c4917e5831" id="r_a63a7e5ac801b5b5197f707c4917e5831"><td class="memItemLeft" align="right" valign="top"><a id="a63a7e5ac801b5b5197f707c4917e5831" name="a63a7e5ac801b5b5197f707c4917e5831"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>integer_sort</b> (int *x, int N)</td></tr>
<tr class="memdesc:a63a7e5ac801b5b5197f707c4917e5831"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper for qsort() specific to integer arrays <br /></td></tr>
<tr class="separator:a63a7e5ac801b5b5197f707c4917e5831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e79878cfab9e7d967e5bb5c44c97780" id="r_a1e79878cfab9e7d967e5bb5c44c97780"><td class="memItemLeft" align="right" valign="top"><a id="a1e79878cfab9e7d967e5bb5c44c97780" name="a1e79878cfab9e7d967e5bb5c44c97780"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>double_sort</b> (double *x, int N)</td></tr>
<tr class="memdesc:a1e79878cfab9e7d967e5bb5c44c97780"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper for qsort() specific to double arrays <br /></td></tr>
<tr class="separator:a1e79878cfab9e7d967e5bb5c44c97780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3078d1adf5b43e721bc8b0db60a4a2c6" id="r_a3078d1adf5b43e721bc8b0db60a4a2c6"><td class="memItemLeft" align="right" valign="top"><a id="a3078d1adf5b43e721bc8b0db60a4a2c6" name="a3078d1adf5b43e721bc8b0db60a4a2c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>index_sort</b> (int *index, double *data, int N)</td></tr>
<tr class="memdesc:a3078d1adf5b43e721bc8b0db60a4a2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper for qsort() to get sorted indicies of input array <br /></td></tr>
<tr class="separator:a3078d1adf5b43e721bc8b0db60a4a2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6403a03e78ca1aeb45a19b322c67fa39" id="r_a6403a03e78ca1aeb45a19b322c67fa39"><td class="memItemLeft" align="right" valign="top"><a id="a6403a03e78ca1aeb45a19b322c67fa39" name="a6403a03e78ca1aeb45a19b322c67fa39"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>list_union</b> (int *A, int *B, int NA, int NB, int *AUB, int *NAUB)</td></tr>
<tr class="separator:a6403a03e78ca1aeb45a19b322c67fa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502de6ed0d0bc0287b928c65c1851739" id="r_a502de6ed0d0bc0287b928c65c1851739"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a502de6ed0d0bc0287b928c65c1851739">gaussian_pdf</a> (double x, double mean, double sigma)</td></tr>
<tr class="memdesc:a502de6ed0d0bc0287b928c65c1851739"><td class="mdescLeft">&#160;</td><td class="mdescRight">return pdf gaussian at x  <br /></td></tr>
<tr class="separator:a502de6ed0d0bc0287b928c65c1851739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffd035f6bc4ee3fd7575f430b99adc0" id="r_abffd035f6bc4ee3fd7575f430b99adc0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abffd035f6bc4ee3fd7575f430b99adc0">get_variance</a> (double *x, int N)</td></tr>
<tr class="memdesc:abffd035f6bc4ee3fd7575f430b99adc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return variance of data vector x  <br /></td></tr>
<tr class="separator:abffd035f6bc4ee3fd7575f430b99adc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adb8cadd16d652865d9c6c381bd2437" id="r_a9adb8cadd16d652865d9c6c381bd2437"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9adb8cadd16d652865d9c6c381bd2437">get_mean</a> (double *x, int N)</td></tr>
<tr class="memdesc:a9adb8cadd16d652865d9c6c381bd2437"><td class="mdescLeft">&#160;</td><td class="mdescRight">return mean of data vector x  <br /></td></tr>
<tr class="separator:a9adb8cadd16d652865d9c6c381bd2437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2434876eaf0d18b4789ed1b8b5fa33e" id="r_ae2434876eaf0d18b4789ed1b8b5fa33e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2434876eaf0d18b4789ed1b8b5fa33e">get_quantile_from_sorted_data</a> (double *data, int N, double q)</td></tr>
<tr class="memdesc:ae2434876eaf0d18b4789ed1b8b5fa33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return quantile q of sorted data vector  <br /></td></tr>
<tr class="separator:ae2434876eaf0d18b4789ed1b8b5fa33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d2107f96f3b2ef0bbb94482325c6b5" id="r_a95d2107f96f3b2ef0bbb94482325c6b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95d2107f96f3b2ef0bbb94482325c6b5">get_min_max</a> (double *data, int N, double *min, double *max)</td></tr>
<tr class="memdesc:a95d2107f96f3b2ef0bbb94482325c6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">get minimum and maximum value of data vector  <br /></td></tr>
<tr class="separator:a95d2107f96f3b2ef0bbb94482325c6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5601d3db9470a42355cad9056f8e36" id="r_adc5601d3db9470a42355cad9056f8e36"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc5601d3db9470a42355cad9056f8e36">incomplete_beta_function</a> (double a, double b, double x)</td></tr>
<tr class="memdesc:adc5601d3db9470a42355cad9056f8e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">GLASS implementation of the normalized incomplete Beta function.  <br /></td></tr>
<tr class="separator:adc5601d3db9470a42355cad9056f8e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a6177e1e9c2d93aee6869aa3123ce1" id="r_ae2a6177e1e9c2d93aee6869aa3123ce1"><td class="memItemLeft" align="right" valign="top"><a id="ae2a6177e1e9c2d93aee6869aa3123ce1" name="ae2a6177e1e9c2d93aee6869aa3123ce1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extract_amplitude_and_phase</b> (int Ns, double *As, double *Dphi, double *M, double *Mf, double *phiR)</td></tr>
<tr class="separator:ae2a6177e1e9c2d93aee6869aa3123ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common math functions used throughout GLASS library. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a09bc87538a6fac156140a346db7c9d48" name="a09bc87538a6fac156140a346db7c9d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bc87538a6fac156140a346db7c9d48">&#9670;&#160;</a></span>amplitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double amplitude </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>f0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>D</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute GW amplitude from intrinsic parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mc</td><td>chirp mass: \(\mathcal{M}\ [{\rm M}_\odot]\) </td></tr>
    <tr><td class="paramname">f0</td><td>initial GW frequency: \( f_0\ [{\rm Hz}]\) </td></tr>
    <tr><td class="paramname">D</td><td>luminosity distance: \( D_L [{\rm pc}]\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( \mathcal{A} = 2 \frac{ \mathcal{M}^{5/3} (\pi f_0)^{2/3} }{D_L} \) </dd></dl>

</div>
</div>
<a id="ab4a868b858e559d8a660ef849bdce1cb" name="ab4a868b858e559d8a660ef849bdce1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a868b858e559d8a660ef849bdce1cb">&#9670;&#160;</a></span>binary_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int binary_search </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Our implementation of the recursive binary search algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>list of values to search over </td></tr>
    <tr><td class="paramname">nmin</td><td>starting index of search </td></tr>
    <tr><td class="paramname">nmax</td><td>stopping index of search </td></tr>
    <tr><td class="paramname">x</td><td>value to search for in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index in array of x </dd></dl>

</div>
</div>
<a id="af44d01bd4c020c57a52e5e31f0d303bb" name="af44d01bd4c020c57a52e5e31f0d303bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44d01bd4c020c57a52e5e31f0d303bb">&#9670;&#160;</a></span>chirpmass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double chirpmass </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute chirp mass from component masses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>mass of primary </td></tr>
    <tr><td class="paramname">m2</td><td>mass of secondary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( \mathcal{M} \equiv (m_1 m_2)^{3/5} (m_1+m_2)^{-1/5} \) </dd></dl>

</div>
</div>
<a id="a2431c31bce9711b866999db85774919a" name="a2431c31bce9711b866999db85774919a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2431c31bce9711b866999db85774919a">&#9670;&#160;</a></span>cholesky_decomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cholesky_decomp </td>
          <td>(</td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to LAPACK Cholesky decomposition routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>\(N\times N\) matrix \(A\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>Cholesky decomposition of \(A = LL^{-1}\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ec422a6a8b4a3eb5f4e1c5c38d7036e" name="a5ec422a6a8b4a3eb5f4e1c5c38d7036e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec422a6a8b4a3eb5f4e1c5c38d7036e">&#9670;&#160;</a></span>component_masses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void component_masses </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mchirp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mtotal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute component masses of binary. </p>
<p>Uses symmetric mass ratio \( \eta \) to compute mass difference \( \delta m = \sqrt{1-4\eta} \) such that \( m_{1,2}=M(1 \pm \delta m)/2\)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Mchirp</td><td>chirp mass \(\mathcal{M}\) ( \( {\rm M}_\odot \) ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Mtotal</td><td>total mass \( M \)( \( {\rm M}_\odot \) ) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m1</td><td>primary mass \( m_1 \) ( \( {\rm M}_\odot \) ) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m2</td><td>secondary mass \( m_2 \)( \( {\rm M}_\odot \) ) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e6346e26742eefbbdbfb6b4980b88bd" name="a1e6346e26742eefbbdbfb6b4980b88bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6346e26742eefbbdbfb6b4980b88bd">&#9670;&#160;</a></span>CubicSplineGLASS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CubicSplineGLASS </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>Nint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>xint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>yint</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to <code>GLASS</code> cubic spline interpolation routines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>number of spline points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>vector of independent-variable spline points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>vector of dependent-variable spline points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nint</td><td>number of interpolated points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">xint</td><td>vector of interpolated independent-variable points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">yint</td><td>vector of interpolated dependent-variable points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1f2679b2ccec317305f387e938aad16" name="aa1f2679b2ccec317305f387e938aad16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f2679b2ccec317305f387e938aad16">&#9670;&#160;</a></span>dbscan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dbscan </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>C</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GLASS implementation of DBSCAN clustering algorithm. </p>
<p>Density based clustering algorithm implemented here for 1D data with simple Euclidean distance measure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>set of data points to cluster </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>maximum distance between two samples to be considered neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>minimum number of samples in a neighborhood to be considered a cluster </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>cluster assignments mapping C[n] = M means X[n] is assigned to cluster M </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>total number of clusters found </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6968b1b7d05ba7e20fc3e548a2b88de" name="ae6968b1b7d05ba7e20fc3e548a2b88de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6968b1b7d05ba7e20fc3e548a2b88de">&#9670;&#160;</a></span>decompose_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decompose_matrix </td>
          <td>(</td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>inverse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>det</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix inversion preserving original and returning L and det. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>input NxN matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse</td><td>inverse of input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>LU decomposition of input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">det</td><td>deteriment of input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of input matrxi </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3bd4cf43262bfd30a5d6707c6c078d5f" name="a3bd4cf43262bfd30a5d6707c6c078d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd4cf43262bfd30a5d6707c6c078d5f">&#9670;&#160;</a></span>fourier_nwip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double fourier_nwip </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>invC</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fourier-domain noise weighted inner product. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>complex amplitude array </td></tr>
    <tr><td class="paramname">b</td><td>complex amplitude array </td></tr>
    <tr><td class="paramname">invC</td><td>inverse covariance matrix </td></tr>
    <tr><td class="paramname">N</td><td>number of frequency bins in sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\((a|b) =  4 \sum_n a^*_n b_n C^-1_n \) </dd></dl>

</div>
</div>
<a id="a502de6ed0d0bc0287b928c65c1851739" name="a502de6ed0d0bc0287b928c65c1851739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502de6ed0d0bc0287b928c65c1851739">&#9670;&#160;</a></span>gaussian_pdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double gaussian_pdf </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>mean</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>sigma</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return pdf gaussian at x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>value for which you want \( p(x) \) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mean</td><td>mean of the Gaussian distribution \((\mu)\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma</td><td>standard deviaiton of the Gaussian distrubtion \((\sigma)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( p(x) = \frac{1}{\sqrt{2\pi}\sigma} exp^{-\frac{1}{2}\frac{(x-\mu)^2}{\sigma^2} } \) </dd></dl>

</div>
</div>
<a id="a9adb8cadd16d652865d9c6c381bd2437" name="a9adb8cadd16d652865d9c6c381bd2437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adb8cadd16d652865d9c6c381bd2437">&#9670;&#160;</a></span>get_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_mean </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return mean of data vector x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean of x </dd></dl>

</div>
</div>
<a id="a95d2107f96f3b2ef0bbb94482325c6b5" name="a95d2107f96f3b2ef0bbb94482325c6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d2107f96f3b2ef0bbb94482325c6b5">&#9670;&#160;</a></span>get_min_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_min_max </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get minimum and maximum value of data vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>unsorted data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of data array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min</td><td>minimum value of data array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max</td><td>maximum vallue of data array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2434876eaf0d18b4789ed1b8b5fa33e" name="ae2434876eaf0d18b4789ed1b8b5fa33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2434876eaf0d18b4789ed1b8b5fa33e">&#9670;&#160;</a></span>get_quantile_from_sorted_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_quantile_from_sorted_data </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return quantile q of sorted data vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>sorted data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of sorted data array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>desired quantile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of data array d at quantile q </dd></dl>

</div>
</div>
<a id="abffd035f6bc4ee3fd7575f430b99adc0" name="abffd035f6bc4ee3fd7575f430b99adc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abffd035f6bc4ee3fd7575f430b99adc0">&#9670;&#160;</a></span>get_variance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_variance </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return variance of data vector x </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variance of x </dd></dl>

</div>
</div>
<a id="abf8a994980adb0c0bc32ec26d52653b0" name="abf8a994980adb0c0bc32ec26d52653b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8a994980adb0c0bc32ec26d52653b0">&#9670;&#160;</a></span>glass_forward_complex_fft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glass_forward_complex_fft </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrappers to FFT functions. </p>
<p>In-place forward and reverse mixed radix Fourier transforms</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data[in/out]</td><td>array to be transformed </td></tr>
    <tr><td class="paramname">N[in]</td><td>size of arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc5601d3db9470a42355cad9056f8e36" name="adc5601d3db9470a42355cad9056f8e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5601d3db9470a42355cad9056f8e36">&#9670;&#160;</a></span>incomplete_beta_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double incomplete_beta_function </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GLASS implementation of the normalized incomplete Beta function. </p>
<p>which is \( I_x(a,b) = B_x(a,b) / B(a,b) \) computed using the relation \( I_x(a,b,x) = (1/a) x^a {}_2F_1(a,1-b,a+1,x)/B(a,b) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( I_x(a,b) \) </dd></dl>

</div>
</div>
<a id="a389ec1a6ef90acd3f0b24d69a6c26a85" name="a389ec1a6ef90acd3f0b24d69a6c26a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389ec1a6ef90acd3f0b24d69a6c26a85">&#9670;&#160;</a></span>initialize_cubic_spline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_cubic_spline </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *</td>          <td class="paramname"><span class="paramname"><em>spline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes cubic spline coefficients for input data {x,y}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">spline</td><td>cubic spline structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>independent variable of interpolant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>dependent variable of interpolant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1081e9f1e9ee4e1eb158abe18efc4656" name="a1081e9f1e9ee4e1eb158abe18efc4656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1081e9f1e9ee4e1eb158abe18efc4656">&#9670;&#160;</a></span>invert_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void invert_matrix </td>
          <td>(</td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix inversion with replacement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matrix</td><td>the input \(N\times N\) matrix, replaced with inverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa832de50c97ec75e53423259310ab758" name="aa832de50c97ec75e53423259310ab758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa832de50c97ec75e53423259310ab758">&#9670;&#160;</a></span>invert_noise_covariance_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void invert_noise_covariance_matrix </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structNoise.html">Noise</a> *</td>          <td class="paramname"><span class="paramname"><em>noise</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analytic in-place inversion of noise covariance matrix. </p>
<p>Substitutes contents of noise-&gt;Cij[n] with inverse, and sets deteriminent noise-&gt;detC[n] </p>

</div>
</div>
<a id="a6bda7243d9d6427acdcf175555f631f6" name="a6bda7243d9d6427acdcf175555f631f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bda7243d9d6427acdcf175555f631f6">&#9670;&#160;</a></span>ipow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ipow </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute integer powers of x by brute force multiplication. </p>
<p>Faster than pow() for small integers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>variable </td></tr>
    <tr><td class="paramname">n</td><td>exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(x^n =  x\times x \times\ ...\times x\) </dd></dl>

</div>
</div>
<a id="a3fd7b3dc905454c44965aac3d9a71afb" name="a3fd7b3dc905454c44965aac3d9a71afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd7b3dc905454c44965aac3d9a71afb">&#9670;&#160;</a></span>matrix_eigenstuff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_eigenstuff </td>
          <td>(</td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>evectors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>evalues</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes eigenvectors and eigenvalues of matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the input \(N\times N\) matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">evector</td><td>2D array of eigenvector components </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">evalue</td><td>1D array of eigenvalues, corresponding with columns of evector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc14e2c155fe0111000033f22a7a3c3b" name="acc14e2c155fe0111000033f22a7a3c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc14e2c155fe0111000033f22a7a3c3b">&#9670;&#160;</a></span>matrix_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_multiply </td>
          <td>(</td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>AB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>\(N\times N\) matrix \(A\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>\(N\times N\) matrix \(B\) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AB</td><td>the matrix product \(AB\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49367382c598af842abd855c380a2259" name="a49367382c598af842abd855c380a2259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49367382c598af842abd855c380a2259">&#9670;&#160;</a></span>post_newtonian_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double post_newtonian_frequency </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mchirp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low PN approximation of gravitational wave frequency given time until coalesence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mchirp</td><td>chirp mass \(\mathcal{M}\) ( \( {\rm M}_\odot \) ) </td></tr>
    <tr><td class="paramname">tc</td><td>coalesence time (s) </td></tr>
    <tr><td class="paramname">t</td><td>current time (s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f gravitational wave frequency (Hz) </dd></dl>

</div>
</div>
<a id="a923c5b7dac33e19c6deca03e9c67e7af" name="a923c5b7dac33e19c6deca03e9c67e7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923c5b7dac33e19c6deca03e9c67e7af">&#9670;&#160;</a></span>post_newtonian_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double post_newtonian_time </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mchirp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mtotal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low PN approximation of current time given the frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mchirp</td><td>chirp mass \(\mathcal{M}\) ( \( {\rm M}_\odot \) ) </td></tr>
    <tr><td class="paramname">Mtotal</td><td>total mass \( M \)( \( {\rm M}_\odot \) ) </td></tr>
    <tr><td class="paramname">tc</td><td>coalesence time (s) </td></tr>
    <tr><td class="paramname">f</td><td>gravitational wave frequency (Hz) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>t current time (s) </dd></dl>

</div>
</div>
<a id="a04b3858ec1f4cad3447ac81c71bd56fa" name="a04b3858ec1f4cad3447ac81c71bd56fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b3858ec1f4cad3447ac81c71bd56fa">&#9670;&#160;</a></span>power_spectrum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double power_spectrum </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute power of complex amplitude in single element of data. </p>
<p>Assumes the <code>data</code> array has alternating real and imaginary terms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>complex amplitude array </td></tr>
    <tr><td class="paramname">n</td><td>desired sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(P =  d^*_n d_n \) </dd></dl>

</div>
</div>
<a id="a4bd6610ef8e1a58a6de67fb414c49e38" name="a4bd6610ef8e1a58a6de67fb414c49e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6610ef8e1a58a6de67fb414c49e38">&#9670;&#160;</a></span>spline_coefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spline_coefficients </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *</td>          <td class="paramname"><span class="paramname"><em>spline</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GLASS implementation of solving for cubic spline interpolation coefficients. </p>
<p>Uses the tridiagonal algorithm to compute the second derivatives d2y of the input data y=f(x). It implicitly assumes 0 2nd deriviative at endpoints.</p>
<p>Returns interpolated value y = f(x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spline-&gt;N</td><td>number of spline points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spline-&gt;x</td><td>vector of independent-variable grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spline-&gt;y</td><td>vector of dependent-variable grid points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">spline-&gt;d2y</td><td>second derivatives of \( f(x)\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bb2d6e5f88d4eaa515af8fbc9228ba9" name="a4bb2d6e5f88d4eaa515af8fbc9228ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb2d6e5f88d4eaa515af8fbc9228ba9">&#9670;&#160;</a></span>spline_interpolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double spline_interpolation </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structCubicSpline.html">CubicSpline</a> *</td>          <td class="paramname"><span class="paramname"><em>spline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GLASS implementation of cubic spline interpolation. </p>
<p>Returns interpolated value y = f(x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spline-&gt;N</td><td>number of spline points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spline-&gt;x</td><td>vector of independent-variable grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spline-&gt;y</td><td>vector of dependent-variable grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spline-&gt;d2y</td><td>second derivatives of \( f(x)\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>value of independent-variable where interpolated value is neede </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated value \( y = f(x)\) </dd></dl>

</div>
</div>
<a id="a3a22b5cf047831bcb6050b4278ef575d" name="a3a22b5cf047831bcb6050b4278ef575d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a22b5cf047831bcb6050b4278ef575d">&#9670;&#160;</a></span>symmetric_mass_ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double symmetric_mass_ratio </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mchirp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Mtotal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute symmetric mass ratio of binary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mchirp</td><td>chirp mass \(\mathcal{M}\) ( \( {\rm M}_\odot \) ) </td></tr>
    <tr><td class="paramname">Mtotal</td><td>total mass \( M \)( \( {\rm M}_\odot \) ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( \eta = \left( \frac{\mathcal{M}}{M} \right)^{5/3} \) </dd></dl>

</div>
</div>
<a id="a0a4e50226df581da9b3949b2e81e24c4" name="a0a4e50226df581da9b3949b2e81e24c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4e50226df581da9b3949b2e81e24c4">&#9670;&#160;</a></span>tukey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tukey </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>alpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tukey window time series data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data[in,out]</td><td>time series to be windowed </td></tr>
    <tr><td class="paramname">alpha[in]</td><td>size of window filter in [s] </td></tr>
    <tr><td class="paramname">N[in]</td><td>size of time series </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7284c2ae59147817959d833bdd8df76c" name="a7284c2ae59147817959d833bdd8df76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7284c2ae59147817959d833bdd8df76c">&#9670;&#160;</a></span>unpack_fft_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unpack_fft_output </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x_packed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearrange output ofRFT. </p>
<p>Real and Imaginary components from RFT functions are not ordered the way the rest of the package expects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x[out]</td><td>array to be filled with ordered fourier coefficients </td></tr>
    <tr><td class="paramname">x_packed[in]</td><td>input array with ill-formatted fourier coefficients </td></tr>
    <tr><td class="paramname">N[in]</td><td>size of arrays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee759a4b7db7f81a483120aa4493240a" name="aee759a4b7db7f81a483120aa4493240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee759a4b7db7f81a483120aa4493240a">&#9670;&#160;</a></span>unwrap_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unwrap_phase </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>phase</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform periodic to linear phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>size of phase array </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">phase</td><td>input from [0,2pi] replaced with unwrapped version </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_cbdb8362360e11eafe2fa3bc74cf0ffd.html">utils</a></li><li class="navelem"><a class="el" href="dir_3067f7d8f9aa80e9f740e3277c5af1f3.html">src</a></li><li class="navelem"><a class="el" href="glass__math_8h.html">glass_math.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
